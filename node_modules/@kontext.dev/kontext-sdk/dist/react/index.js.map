{"version":3,"sources":["../../src/react/use-realtime-context.tsx"],"names":["useRealtimeContext","options","userId","apiKey","useKontext","queryClient","useQueryClient","state","setState","useState","enabled","onUpdate","onUpdateRef","useRef","isMountedRef","useEffect","isCleanedUp","apiUrl","wsUrl","wsClient","createWSClient","trpcClient","createTRPCClient","splitLink","op","wsLink","superjson","httpBatchLink","subscription","event","prev","error","usePollingContext","intervalMs","isConnected","isPolling","setIsPolling","interval"],"mappings":"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","file":"index.js","sourcesContent":["'use client';\n\nimport { useEffect, useState, useRef } from 'react';\nimport { useKontext } from './context';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { createTRPCClient, createWSClient, splitLink, wsLink, httpBatchLink } from '@trpc/client';\nimport superjson from 'superjson';\nimport type { AppRouter } from '../types/api-types';\n\nexport interface RealtimeContextOptions {\n  enabled?: boolean;\n  onUpdate?: (event: any) => void;\n}\n\nexport interface RealtimeContextState {\n  isConnected: boolean;\n  lastUpdate: Date | null;\n  updateCount: number;\n  recentUpdates: Array<{\n    type: string;\n    timestamp: Date;\n    metadata?: any;\n  }>;\n}\n\n/**\n * Hook for real-time context updates via WebSocket subscriptions\n */\nexport function useRealtimeContext(options: RealtimeContextOptions = {}) {\n  const { userId, apiKey } = useKontext();\n  const queryClient = useQueryClient();\n  const [state, setState] = useState<RealtimeContextState>({\n    isConnected: false,\n    lastUpdate: null,\n    updateCount: 0,\n    recentUpdates: [],\n  });\n\n  const { enabled = true, onUpdate } = options;\n\n  // Use ref to store the callback to avoid dependency issues\n  const onUpdateRef = useRef(onUpdate);\n  onUpdateRef.current = onUpdate;\n\n  // Store cleanup flag to prevent state updates after unmount\n  const isMountedRef = useRef(true);\n\n  useEffect(() => {\n    isMountedRef.current = true;\n\n    if (!enabled || !userId || !apiKey) {\n      return;\n    }\n\n    let isCleanedUp = false;\n\n    // Parse API URL to get WebSocket URL\n    const apiUrl = process.env.NEXT_PUBLIC_KONTEXT_API_URL || 'https://api.kontext.dev';\n    const wsUrl = apiUrl.replace('https://', 'wss://').replace('http://', 'ws://');\n\n    // Create WebSocket client\n    const wsClient = createWSClient({\n      url: `${wsUrl}/trpc`,\n      connectionParams: async () => ({\n        'x-api-key': apiKey,\n      }),\n    });\n\n    // Create tRPC client with WebSocket support\n    const trpcClient = createTRPCClient<AppRouter>({\n      links: [\n        splitLink({\n          condition: (op) => op.type === 'subscription',\n          true: wsLink({\n            client: wsClient,\n            transformer: superjson,\n          }),\n          false: httpBatchLink({\n            url: `${apiUrl}/trpc`,\n            headers: {\n              'x-api-key': apiKey,\n            },\n            transformer: superjson,\n          }),\n        }),\n      ],\n    });\n\n    // Subscribe to context updates\n    let subscription: any;\n    try {\n      subscription = (trpcClient as any).data.contextUpdates.subscribe(\n        { userId },\n        {\n          onData: (event: any) => {\n            if (isCleanedUp || !isMountedRef.current) return;\n\n            console.log('Received context update:', event);\n\n            // Update state - ensure timestamp is properly handled\n            setState((prev) => ({\n              isConnected: true,\n              lastUpdate: new Date(),\n              updateCount: prev.updateCount + 1,\n              recentUpdates: [\n                {\n                  type: event.type || 'unknown',\n                  timestamp: event.timestamp ? new Date(event.timestamp) : new Date(),\n                  metadata: event.metadata || {},\n                },\n                ...prev.recentUpdates.slice(0, 9), // Keep last 10 updates\n              ],\n            }));\n\n            // Invalidate context queries to trigger refetch\n            queryClient.invalidateQueries({ queryKey: ['context', userId] });\n\n            // Call user callback if provided\n            if (onUpdateRef.current) {\n              onUpdateRef.current(event);\n            }\n          },\n          onError: (error: any) => {\n            if (isCleanedUp || !isMountedRef.current) return;\n\n            console.error('Subscription error:', error);\n            setState((prev) => ({\n              ...prev,\n              isConnected: false,\n            }));\n          },\n        },\n      );\n    } catch (error) {\n      console.error('Failed to create subscription:', error);\n      return;\n    }\n\n    // Mark as connected\n    if (!isCleanedUp && isMountedRef.current) {\n      setState((prev) => ({\n        ...prev,\n        isConnected: true,\n      }));\n    }\n\n    // Cleanup\n    return () => {\n      isCleanedUp = true;\n      isMountedRef.current = false;\n      if (subscription) {\n        subscription.unsubscribe();\n      }\n      wsClient.close();\n      // Don't update state in cleanup to avoid issues\n    };\n  }, [enabled, userId, apiKey, queryClient]);\n\n  return state;\n}\n\n/**\n * Hook for automatic polling fallback when WebSocket is not available\n */\nexport function usePollingContext(intervalMs: number = 30000) {\n  const { userId, isConnected } = useKontext();\n  const queryClient = useQueryClient();\n  const [isPolling, setIsPolling] = useState(false);\n\n  useEffect(() => {\n    if (!isConnected || !userId) {\n      return;\n    }\n\n    setIsPolling(true);\n    const interval = setInterval(() => {\n      // Invalidate context to trigger refetch\n      queryClient.invalidateQueries({ queryKey: ['context', userId] });\n    }, intervalMs);\n\n    return () => {\n      setIsPolling(false);\n      clearInterval(interval);\n    };\n  }, [isConnected, userId, intervalMs, queryClient]);\n\n  return { isPolling };\n}\n"]}