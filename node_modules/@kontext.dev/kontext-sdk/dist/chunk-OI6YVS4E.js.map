{"version":3,"sources":["../src/client/trpc.ts","../src/client/client.ts"],"names":["createTRPCClient","apiUrl","apiKeyOrToken","isApiKey","createTRPCProxyClient","httpBatchLink","superjson","url","options","Persona","config","userId","task","maxTokens","privacyLevel","authenticatedTrpc","response","error","message","code","statusCode"],"mappings":"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","file":"chunk-OI6YVS4E.js","sourcesContent":["import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';\nimport superjson from 'superjson';\n\n/**\n * Creates a tRPC client for the Kontext SDK\n *\n * @param apiUrl - The API endpoint URL\n * @param apiKeyOrToken - API key (ktext_*) or session token for authentication\n */\nexport function createTRPCClient(apiUrl: string, apiKeyOrToken: string) {\n  // Check if this is an API key (starts with ktext) or a session token\n  const isApiKey = apiKeyOrToken.startsWith('ktext');\n\n  // Use 'any' type here to avoid internal dependency issues\n  // The SDK will have proper type safety through the wrapper client class\n  return createTRPCProxyClient<any>({\n    links: [\n      httpBatchLink({\n        url: `${apiUrl}/trpc`,\n        transformer: superjson,\n        maxItems: 10, // Maximum number of operations in a single batch\n        maxURLLength: 2083, // Prevent URLs from becoming too long\n        async headers() {\n          if (isApiKey) {\n            // Use x-api-key header for API key authentication\n            return {\n              'x-api-key': apiKeyOrToken,\n            };\n          } else {\n            // For session tokens, use Authorization Bearer format\n            return {\n              Authorization: `Bearer ${apiKeyOrToken}`,\n            };\n          }\n        },\n        fetch(url, options) {\n          return fetch(url, {\n            ...options,\n            // Add connection pooling for better performance\n            keepalive: true,\n          });\n        },\n      }),\n    ],\n  });\n}\n\nexport type KontextTRPCClient = ReturnType<typeof createTRPCClient>;\n","import type { PersonaConfig, GetContextOptions, PersonaError, Context } from './types';\nimport { createTRPCClient } from './trpc';\n\n/**\n * Main Persona SDK client\n * Provides a simple API for developers to get personalized context\n */\nexport class Persona {\n  private config: Required<PersonaConfig>;\n\n  constructor(config: PersonaConfig) {\n    // Validate that API key is provided\n    if (!config.apiKey) {\n      throw new Error('Persona API key is required');\n    }\n\n    // Set defaults\n    this.config = {\n      apiKey: config.apiKey,\n      providers: config.providers || ['gmail', 'preferences'],\n      apiUrl: config.apiUrl || 'https://api.kontext.dev',\n      cache: {\n        ttl: config.cache?.ttl || 300,\n        storage: config.cache?.storage || 'memory',\n      },\n      limits: {\n        maxTokensPerRequest: config.limits?.maxTokensPerRequest || 2000,\n        monthlyBudget: config.limits?.monthlyBudget || 0,\n      },\n    };\n  }\n\n  /**\n   * Get personalized context for a user\n   * This is the main method developers will use\n   */\n  async getContext(options: GetContextOptions): Promise<Context> {\n    // Validate input options\n    if (!options) {\n      throw this.createError(\n        'GetContextOptions is required. Please provide an object with at least a userId field.',\n        'INVALID_OPTIONS',\n        400,\n      );\n    }\n\n    const { userId, task, maxTokens, privacyLevel } = options;\n\n    // Validate userId is provided and is a string\n    if (!userId || typeof userId !== 'string') {\n      throw this.createError(\n        'Valid userId is required. Please provide a non-empty string userId.',\n        'INVALID_USER_ID',\n        400,\n      );\n    }\n\n    // Validate maxTokens if provided\n    if (maxTokens !== undefined && (typeof maxTokens !== 'number' || maxTokens <= 0)) {\n      throw this.createError(\n        'maxTokens must be a positive number if provided.',\n        'INVALID_MAX_TOKENS',\n        400,\n      );\n    }\n\n    // Validate privacyLevel if provided\n    if (privacyLevel && !['strict', 'moderate', 'none'].includes(privacyLevel)) {\n      throw this.createError(\n        'privacyLevel must be one of: strict, moderate, none',\n        'INVALID_PRIVACY_LEVEL',\n        400,\n      );\n    }\n\n    // Create tRPC client with API key\n    const authenticatedTrpc = createTRPCClient(this.config.apiUrl, this.config.apiKey);\n\n    try {\n      // Call backend context endpoint with userId\n      const response = await (authenticatedTrpc as any).data.context.query({\n        userId, // Pass userId as part of the query\n        task: task || 'general',\n        maxFacts: maxTokens ? Math.min(maxTokens / 10, 100) : undefined, // Rough conversion from tokens to facts\n        cachePolicy: 'fresh', // Changed from 'cached' to always get fresh context\n        includeRecentData: true,\n        privacyLevel: privacyLevel || 'none',\n      });\n\n      // Transform response to match SDK Context interface\n      // The API returns more data than the SDK exposes, so we simplify it\n      return {\n        systemPrompt: response.systemPrompt,\n        metadata: {\n          userId: options.userId,\n          timestamp: response.metadata?.generatedAt || new Date(),\n          providers: ['gmail'], // TODO: Track actual providers used\n        },\n        // Token count would need to be calculated from systemPrompt length\n        tokenCount: response.systemPrompt.length / 4, // Rough estimate: 1 token â‰ˆ 4 chars\n      };\n    } catch (error) {\n      // Provide more specific error messages based on the error type\n      const message = error instanceof Error ? error.message : 'Failed to get context';\n\n      // Check for common tRPC/API errors\n      if (message.includes('Invalid input') || message.includes('expected object')) {\n        throw this.createError(\n          'Invalid request format. This may be a SDK version mismatch with the API.',\n          'INVALID_REQUEST_FORMAT',\n          400,\n        );\n      }\n\n      if (message.includes('OAuth access') || message.includes('No OAuth')) {\n        throw this.createError(\n          'User has not authorized access. Please ensure the user has connected their account.',\n          'UNAUTHORIZED_USER',\n          403,\n        );\n      }\n\n      // Generic error fallback\n      throw this.createError(message, 'CONTEXT_FAILED', 500);\n    }\n  }\n\n  /**\n   * Disconnect user and delete their data\n   * This calls the GDPR deleteData endpoint\n   */\n  async disconnect(userId: string): Promise<void> {\n    // Validate userId is provided and is a string\n    if (!userId || typeof userId !== 'string') {\n      throw this.createError(\n        'Valid userId is required for disconnect. Please provide a non-empty string userId.',\n        'INVALID_USER_ID',\n        400,\n      );\n    }\n\n    try {\n      // Create tRPC client with API key\n      const authenticatedTrpc = createTRPCClient(this.config.apiUrl, this.config.apiKey);\n\n      // Call GDPR endpoint with userId\n      await (authenticatedTrpc as any).gdpr.deleteData.mutate({ userId });\n    } catch (error) {\n      // Provide more specific error messages based on the error type\n      const message = error instanceof Error ? error.message : 'Failed to disconnect';\n\n      // Check for specific API errors\n      if (message.includes('not found') || message.includes('does not exist')) {\n        throw this.createError(\n          'User not found. The user may have already been disconnected.',\n          'USER_NOT_FOUND',\n          404,\n        );\n      }\n\n      // Generic error fallback\n      throw this.createError(message, 'DISCONNECT_FAILED', 500);\n    }\n  }\n\n  /**\n   * Create a PersonaError\n   */\n  private createError(message: string, code: string, statusCode?: number): PersonaError {\n    const error = new Error(message) as PersonaError;\n    error.name = 'PersonaError';\n    error.code = code;\n    error.statusCode = statusCode;\n    return error;\n  }\n}\n"]}